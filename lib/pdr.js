/**
 * This module includes tools for validating PDRs
 * and generating PDRD and PAN messages
 */

'use strict';

import fs from 'fs';
import pvl from 'pvl';
import log from 'cumulus-common/log';
import { basename } from 'path';


export class PDRParsingError {

  constructor(type, pdrName) {
    this.name = 'BasePDRDError';
    this.pdrName = pdrName;
    this.message = this.getMessage(type) || 'PDR Parsing error';
    this.stack = (new Error()).stack;
  }

  getMessage(type) {
    if (!type) {
      return null;
    }

    switch (type.toUpperCase()) {
      case 'UNREADABLE':
        return 'PDR unreadable';
      case 'FILE_CKSUM_VALUE':
        return 'MISSING FILE_CKSUM_VALUE PARAMETER';
      case 'FILE_CKSUM_TYPE':
        return 'MISSING FILE_CKSUM_TYPE PARAMETER';
      case 'CHECKSUM':
        return 'UNSUPPORTED CHECKSUM TYPE';
      default:
        return `INVALID ${type.toUpperCase()}`;
    }
  }

}


function getItem(spec, pdrName, name, must = true) {
  const item = spec.get(name);
  if (item) {
    return item.value;
  }

  if (must) {
    throw new PDRParsingError(name, pdrName);
  }

  return null;
}


/**
 * Makes sure that a FILE Spec has all the required files and returns
 * the content as an object. Throws error if anything is missing
 * For more info refer to https://github.com/cumulus-nasa/cumulus-api/issues/104#issuecomment-285744333
 *
 * @param {object} spec PDR spec object generated by PVL
 * @returns {object} throws error if failed
 */
export function parseSpec(pdrName, spec) {
  const get = getItem.bind(null, spec, pdrName);

  // check each file_spec has DIRECTORY_ID, FILE_ID, FILE_SIZE
  const path = get('DIRECTORY_ID');
  const filename = get('FILE_ID');
  const fileSize = get('FILE_SIZE');

  const checksumType = get('FILE_CKSUM_TYPE', false);
  const checksumValue = get('FILE_CKSUM_VALUE', false);

  // if it has cksum, make sure both FILE_CKSUM_TYPE and FILE_CKSUM_VALUE are present
  if (checksumType || checksumValue) {
    if (!checksumType) {
      throw new PDRParsingError('FILE_CKSUM_TYPE', pdrName);
    }

    if (!checksumValue) {
      throw new PDRParsingError('FILE_CKSUM_VALUE', pdrName);
    }
  }

  // make sure FILE_CKSUM_TYPE value is CKSUM
  if (checksumType && checksumType !== 'CKSUM') {
    throw new PDRParsingError('CHECKSUM', pdrName);
  }

  // make sure FILE_CKSUM_VALUE is numeric
  if (checksumValue && typeof checksumValue !== 'number') {
    throw new PDRParsingError('FILE_CKSUM_VALUE', pdrName);
  }

  return { path, filename, fileSize, checksumType, checksumValue };
}


export function parsePdr(pdrFilePath) {
  // then read the file and and pass it to parser
  const pdrFile = fs.readFileSync(pdrFilePath);
  const obj = {
    pdrName: basename(pdrFilePath),
    granules: []
  };
  try {
    // because MODAPS PDRs do not follow the standard ODL spec
    // we have to make sure there are spaces before and after every
    // question mark
    let pdrString = pdrFile.toString().replace(/((\w*)=(\w*))/g, '$2 = $3');

    // temporary fix for PVL not recognizing quoted strings as symbols
    pdrString = pdrString.replace(/"/g, '');

    let parsed = pvl.pvlToJS(pdrString);

    // check if the PDR has groups
    // if so, get the objects inside the first group
    // TODO: handle cases where there are more than one group
    const groups = parsed.groups();
    if (groups.length > 0) {
      parsed = groups[0];
    }

    // Get all the file groups
    const fileGroups = parsed.objects('FILE_GROUP');

    for (const group of fileGroups) {
      // get all the file specs in each group
      const specs = group.objects('FILE_SPEC');

      if (specs.length === 0) {
        throw new Error();
      }

      const files = specs.map(parseSpec.bind(null, obj.pdrName));
      obj.granules.push({
        granuleSize: files.reduce((total, file) => total + file.fileSize, 0),
        files
      });
    }

    // check file count
    const fileCount = obj.granules.reduce((t, g) => t + g.files.length, 0);
    const expectedFileCount = parsed.get('TOTAL_FILE_COUNT').value;
    if (fileCount !== expectedFileCount) {
      log.error(`File Count Provided: ${expectedFileCount} | Files found: ${fileCount}`);
      throw new PDRParsingError('FILE COUNT', obj.pdrName);
    }


    obj.granulesCount = fileGroups.length;
    obj.filesCount = fileCount;
    obj.totalSize = obj.granules.reduce((t, g) => t + g.granuleSize, 0);

    return obj;
  }
  catch (e) {
    if (!(e instanceof PDRParsingError)) {
      throw new PDRParsingError('UNREADABLE', obj.pdrName);
    }
    throw e;
  }
}
